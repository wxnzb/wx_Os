## 相对过程：这章主要是增加了loader的内容(因此mbr读入的扇区数应改变大了，不然就只把一部分放入了硬盘)
- 相对上一章的主要打印，这在loader.s中开启了保护模式(构建并加载gdb段描述符),在保护模式下打印了p
## 保护模式是在 loader.bin 中进入的

### 1.mbr.S

由于 loader.bin 超过了 512 字节，所以我们要把 mbr.S 中加载 loader.bin 的读入扇区数增大，目前它是 1 扇区，为了避免将来再次修改，直接改成读入 4 扇区

loader.bin 是由 mbr.bin 中的函数 rd_disk_m_16 负责加载的，
其参数“读入扇区数”存入 cx 寄存器中。
所以，如果 loader.bin 的大小超过 mbr 所读取的扇区数，
切记一定要修改 mbr.S 中函数 rd_disk_m_16 的读入扇区数，
如代码 mbr.S 中的第 52 行。
如果忘记的话，由于被加载的程序不全，CPU 在执行时就会执行到
一些莫名其妙的代码（内存中的数据“恰好”符合某种指令，
虽然用了“恰好”，但这种情况很普遍，一
堆 01 二进制串，总能瞎猫碰上死耗子成为某个指令）
 ，查看反汇编代码，根本就不是自己写的指令。

### 2.boot.int

更新文件 include/boot.inc，里面是一些配置信息，loader.S 
中用到的配置都是定义在boot.inc 中的符号
- “由于在实模式下时，指令按照16位指令格式来译码，第78~82行既有16位指令，又有32位指令，所以流水线把32位指令按照16位译码就会出错。解决这问题的方法就是无条件跳转指令清空流水线。”