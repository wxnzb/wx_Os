## 相对过程：
- 在device目录下添加ioqueue.c文件
- 在device/ioqueue.c文件中
- 定义了ioqueue_init(初始化io队列ioq)函数，他调用了lock_init()函数
- 定义了next_pos(返回pos在缓冲区中的位置)函数
- 定义了ioq_empty(判断io队列是否为空)函数
- 定义了ioq_full(判断io队列是否已满)函数
- 定义了ioq_wait( 使当前生产者或消费者在此缓冲区上等待)函数，他调用了ASSERT(),running_thread()函数，thread_block()函数
- 定义了wakeup(唤醒waiter)函数，他调用了thread_unblock()函数
- 定义了ioq_getchar(消费者从ioq队列中获取一个字符)函数，他调用了ASSERT(),intr_get_status()函数，ioq_empty()函数，lock_acquire()函数，ioq_wait()函数，lock_release()函数，wakeup()函数
- 定义了ioq_putchar()函数，他调用了ASSERT()，ioq_full()函数，ioq_wait*()函数，lock_release()函数， wakeup()函数
-----------------------------------
- 在device/keyboard.c文件中
- 将3的183行的put_char()函数变为一个if判断，这里面调用了ioq_full()函数，put_char()函数，ioq_putchar()函数
- 但是博客原上面是put_char()函数变为一个if判断，这里面调用了ioq_full()函数，ioq_putchar()函数，没有调用put_char()函数，所以看上去比较清晰，就先注释掉上面的，用下面的
-----------------------------------
- 在kernal/interrupt.c文件中
- 将 outb(PIC_M_DATA,0xfd);   // 只支持键盘中断变为 outb(PIC_M_DATA,0xfc);   // 只支持键盘中断和时钟中断
-----------------------------------
- 在kernal/main.c文件中
- 定义了k_thread_a(在线程中运行的函数)函数，他调用了intr_disable()函数，ioq_empty()函数，console_put_str()函数，ioq_getchar()函数，console_put_char()函数，intr_set_status()函数
- 定义了k_thread_b(在线程中运行的函数)函数，他调用了intr_disable()函数，ioq_empty()函数，console_put_str()函数，ioq_getchar()函数，console_put_char()函数，intr_set_status()函数
- 在main函数中，还调用了put_str()函数，thread_start()函数，intr_enable()函数