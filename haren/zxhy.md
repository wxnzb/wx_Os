# 操作系统真相还原
 
-[真相还原gogogo!](#真相还原gogogo!)\
 -[第0章：一些你可能正感到迷惑的问题](#第0章：一些你可能正感到迷惑的问题)\
  -[软件如何访问硬件](#软件如何访问硬件)\
  -[特权级](#特权级)\
  -[内存访问为什么要分段](#内存访问为什么要分段)
  -[代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗](#代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗)\
  -[物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别](#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别)\
  -[什么是段重叠](#什么是段重叠)\
  -[平坦模型](#平坦模型)\
  -[BIOS中断、DOS中断、Linux中断的区别](#BIOS中断、DOS中断、Linux中断的区别)\
  -[局部变量和函数参数为什么要放在栈中](#局部变量和函数参数为什么要放在栈中)\
  -[Section和Segment的区别](#Section和Segment的区别)\
  -[BIOS、MBR、DBR、OBR](#BIOS、MBR、DBR、OBR)\
 -[第二章：编写MBR主引导记录，让我们开始掌权](#第二章：编写MBR主引导记录，让我们开始掌权)\
  -[0x7c00?Why???](#0x7c00?Why???)\
 -[第三章：完善MBR](#第三章：完善MBR)\
  -[计算机启动过程](#计算机启动过程)\
  -[CPU的实模式](#CPU的实模式)\
  -[CPU工作原理](#CPU工作原理)\
  -[CPU的寄存器](#CPU的寄存器)\
  -[实模式下CPU内存寻址方式](#实模式下CPU内存寻址方式)\
   -[寄存器寻址](#寄存器寻址)\
   -[立即数寻址](#立即数寻址)\
   -[内存寻址](#内存寻址)\
   -[直接寻址](#直接寻址)\
   -[基址寻址](#基址寻址)\
   -[変址寻址](#変址寻址)\
   -[基址变址寻址](#基址变址寻址)\
  -[实模式下的ret](#实模式下的ret)\
  -[实模式下的call](#实模式下的call)\
   -[16位实模式相对近调用](#16位实模式相对近调用)\
   -[16位实模式间接绝对近调用](#16位实模式间接绝对近调用)\
   -[16位实模式直接绝对远调用](#16位实模式直接绝对远调用)\
   -[16位实模式间接绝对远调用](#16位实模式间接绝对远调用)\
  -[实模式下的jmp](#实模式下的jmp)\
  -[让我们直接对显示器说点什么吧](#让我们直接对显示器说点什么吧)\
   -[CPU如何与外设通信—IO接口](#CPU 如何与外设通信—IO 接口)\
   -[显卡概述](#显卡概述)\
   -[显存、显卡、显示器](#显存、显卡、显示器)\
  -[硬盘介绍](#硬盘介绍)\
   -[硬盘控制器端口](#硬盘控制器端口)\
   -[常用的硬盘操作方法](#常用的硬盘操作方法)\



## 第0章：一些你可能正感到迷惑的问题

### 软件如何访问硬件

+ 硬件更新非常迅速，操作系统为了适应各种不断迭代更新的硬件，出现了各种硬件适配器（`IO`接口）

+ 接口分为串行接口和并行接口

访问外部硬件有两个方式

1. 将某个外设的内存映射到一定范围的地址空间中,`CPU` 通过地址总线访问该内存区域时会落到外设的内存中,这种映射让 `CPU` 访问外设的内存就如同访问主板上的物理内存一样。例如显卡，显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 1MB 的 0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，往这片内存上写字节便是往屏幕上打印内容。

2. 外设是通过 `IO` 接口与 `CPU` 通信的,`CPU` 访问外设,就是访问 `IO` 接口,由 `IO` 接口将信息传递给另一端的外设,也就是说,`CPU` 从来不知道有这些设备的存在,它只知道自己操作的 `IO` 接口。

>  如何访问到 `IO` 接口呢
>
> 答案就是 `IO` 接口上面有一些寄存器,访问 `IO` 接口本质上就是访问这些寄存器,这些寄存器就是人们常说的端口。这些端口是人家 `IO` 接口给咱们提供的接口。

------


### 特权级

+ 应用程序处于特权级 3,操作系统内核处于特权级 0。

+  扩展：

用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。


### 内存访问为什么要分段

分段是给`CPU`用的访问内存的方式。

 + 早期程序运行时使用的是物理地址，编译后的代码在物理内存中起始地址相同，代码会发生冲突，相互覆盖。
 程序分段首先是为了重定位，重定位可以将物理地址冲突的程序挪到其他段

 + 程序分段首先是为了重定位，重定位可以将物理地址冲突的程序挪到其他段

> 1M 是 2 的 20 次方,1MB 内存需要 20 位的地址才能访问到,如何做到用 16 位寄存器访问 20 位地址空间呢?
>
> 这是因为 CPU 设计者在地址处理单元中动了手脚,该地址部件接到“段基址+段内偏移地址”的地址后,自动将段基址乘以 16,即左移了 4 位,然后再和 16 位的段内偏移地址相加,这下地址变成了 20 位了

------

#### 代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗

**程序不是一定要分段才能运行的,分段只是为了使程序更加优美。**

只要给出 `CPU` 第一个指令的起始地址,`CPU` 在它执行本指令的同时,它会自动获取下一条的地址,然后重复上述过程,继续执行,继续取址。这就要求程序中的指令都是挨着的，彼此之间无空隙。

> 程序中不是有对齐这回事吗?为了对齐,编译器在程序中塞了好多 0。是的,对齐确实是让程序中出现了好多空隙,但这些空隙是数据间的空隙,指令间不存在空隙,下一条指令的地址是按照前面指令的尺寸大小排下来的。即使指令间有空隙或其他非指令的数据,这也仅仅是在物理上将其断开了,依然可以用 `jmp`指令将非指令部分跳过以保持指令在逻辑上连续

**为了让程序内指令接连不断地执行,要把指令全部排在一起,形成一片连续的指令区域,这就是代码段。把数据连续地并排在一起存储形成的段落，就称为数据段。**

**尽量把同一属性的数据放在一起,这样易于维护。** 这样有以下好处：


- 可以为它们赋予不同的属性。数据需要有可写的属性，代码需要有只读的属性。
- 为了提高 `CPU` 内部缓存的命中率。
- 节省内存。程序中存在一些只读的部分,比如代码,当一个程序的多个副本同时运行时(比如同时执行多个 ls命令时),没必要在内存中同时存在多个相同的代码段,这将浪费有限的物理内存资源,只要把这一个代码段共享就可以了。

> 数据段或代码段的属性是谁给添加上的呢,是谁又去根据属性保护程序的呢
>
> 编译器.他负责挑选出数据具备的属性,从而根据属性将程序片段分类,比如,划分出了只读属性的代码段和可写属性的数据段。
>
> 操作系统通过设置 `GDT` 全局描述符表来构建段描述符,在段描述符中指定段的位置、大小及属性(包括 `S` 字段和 `TYPE` 字段)。是真正给段添加属性的地方。
>
> `CPU` 中的段寄存器提前被操作系统赋予相应的选择子,从而确定了指向的段。

总结一下,**程序中的段只是逻辑上的划分,用于不同数据的归类,但是可以用 `CPU` 中的段寄存器直接指向它们**,然后用内存分段机制去程序中分段在平坦模型中访问程序中的段。

内存分段机制？

------

#### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

+ 物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。

+ 在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直 接用此地址访问内存。

+ 而在保护模式下，“段基址+段内偏移地址”称为线性地址，此时的段基址是选择子。

+ 若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是 虚拟地址。

![alt text](image.png)

------

#### 什么是段重叠

`CPU` 的内存寻址方式是:给我一个段基址,再给我一个相对于该段起始位置的偏移地址,我就能访问到相应内存。它并不要求一个内存地址只隶属于某一个段,所以在上面的图  中,欲访问内存 `0xC03`,段基址可以选择 `0xC00`, `0xC01`,`0xC02`,`0xC03`,只不过是段内偏移量要根据段基地址来调整罢了。用这种“段基地址:段内偏移”的组合,`0xC00:3` 和`0xC02:1` 是等价的,它们都访问到同一个物理内存块。但段的大小决定于段内偏移地址寻址范围,假设段 A 的段基址是从 0xC00 `开始`,段 B 的段基址是从 `0xC02` 开始,在 16 位宽度的寻址范围内,这两个段都能访问到 `0xC05` 这块内存。用段 A 去访问,其偏移为 5,用段 B 去访问,其偏移量为 3。这样一来,用段 B 和段 A 在地址 0xC02 之后,一直到段 B偏移地址为 `0xfffe` 的部分,像是重叠在一起了,这就是段重叠。

![alt text](image-1.png)

------


### 平坦模型

平坦模型（Flat Model）是一种**内存管理模型**，它将整个物理内存视为单一的、连续的地址空间，不区分段。这与分段模型和分页模型是相对的。

在平坦模型中，**内存地址由一个单一的线性地址空间表示，该空间从零开始，一直延伸到系统支持的最大物理地址。** 这种模型简化了内存管理，使得程序员不需要关心段的概念，而是使用连续的线性地址。

------


### 寄存器

`CS`—代码段寄存器(`Code Segment Register`),其值为代码段的段基值。

`DS`—数据段寄存器(`Data Segment Register`),其值为数据段的段基值

`ES`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,称为“附加”是因为此段寄存器用途不像其他 `sreg` 那样固定,可以额外做他用。

`FS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,同上,用途不固定,使用上灵活机动。

`GS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值。

`SS`—堆栈段寄存器(`Stack Segment Register`),其值为堆栈段的段值。

> 32 位 `CPU` 有两种不同的工作模式:实模式和保护模式。
> 每种模式下,段寄存器中值的意义是不同的,但不管其为何值,在段寄存器中所表达的都是指向的段在哪里。
>
> 在实模式下,`CS`、`DS`、`ES`、`SS` 中的值为段基址,是具体的物理地址,内存单元的逻辑地址仍为“段基值:段内偏移量”的形式。在保护模式下,装入段寄存器的不再是段地址,而是“段选择子”(`Selector`),当然,选择子也是数值,其依然为 16 位宽度。

综上所述，在32位CPU中，不管在16为实模式还是32位保护模式下，用的段寄存器都是同一组,`sreg` 都是 16 位宽。

------

### BIOS中断、DOS中断、Linux中断的区别
+ 如果事件来自于 CPU 内部就称为异常，即 Exception,如果事件来自于外部，也就是该事件由外部设备发出并通知了 CPU，这个事件就称为中断
+ 计算机 启动之初，中断向量表中的中断例程是由 BIOS 建立的，它从物理内存地址 0x0000 处初始化并在中断向 量表中添加各种处理例程
 > BIOS 为什么添加中断处理例程呢？
 > 
 > 1.给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写 成中断函数，直接调用多省心
 > 2.给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了

 ------

 > CPU 如何访问到外设的 ROM
 >
 > 1.内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）
 >  2.端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存

------
+ Linux中断

Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了， 取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表


### 局部变量和函数参数为什么要放在栈中

局部变量只是自己在用,放在数据段中纯属浪费空间,没有必要,故将其放在自己的栈中,随时可以清理,真正体现了局部的意义。

函数参数为什么会放到栈区呢?

- 第一也是其局部性导致的,只有这个函数用这个参数,何必将其放在数据段呢。
- 第二,这是因为函数是在程序执行过程中调用的,属于动态的调用,编译时无法预测会何时调用及被调用的次数，其参数和函数的返回地址也要内存来存储,所以也不知道其会需要多少内存。

------

### Section和Segment的区别

section 称为节,是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域,汇编器会将这两个关键字修饰的区域在目标文件中编译成节,也就是说“节”最初诞生于目标文件中。

segment 称为段,是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合,这个集合称为 segment,也就是段,链接器把目标文件链接成可执行文件,因此段最终诞生于可执行文件中。

------


### BIOS、MBR、DBR、OBR

BIOS是计算机接电后运行的第一个程序

MBR会在BIOS干完一些基础工作后从BIOS那接手系统的控制权（BIOS将0盘0道1扇区的MBR加载到物理地址0x7c00）

MBR将系统控制权交给内核加载器OBR

MBR 引导扇区中的内容是：

   + 446 字节的引导程序及参数
   + 64 字节的分区表；
   + 2 字节结束标记 0x55 和 0xaa。


OBR是DBR遗留下来的,DBR 中的内容大概是：

   + 跳转指令，使 MBR 跳转到引导代码
   + 厂商信息、DOS 版本信息
   + BIOS 参数块 BPB，即 BIOS Parameter Block
   + 操作系统引导程序
   + 结束标记 0x55 和 0xaa


EBR是扩展分区中为了兼容 MBR 才提出的概念,主要是兼容 MBR 中的分区表。分区是用分区表来描述的,MBR 中有分区表,扩展分区中的是一个个的逻辑分区,因此扩展分区中也要有分区表,为扩展分区存储分区表的扇区称为 EBR,

------



## 编写MBR主引导记录，让我们开始掌权

### 0x7c00?Why???

+ BIOS 最后一项工作校验启动盘中位于 0 盘 0 道 1 扇区的内容

> 8086CPU 要求物理地址 0x0～0x3FF 存放中断向量表，所以此处不能动了，再选新的地方看看。 按 DOS 1.0 要求的最小内存 32KB 来说，MBR 希望给人家尽可能多的预留空间，这样也是保全自己 的作法，免得过早被覆盖。所以 MBR 只能放在 32KB 的末尾。 MBR 本身也是程序，是程序就要用到栈，栈也是在内存中的，MBR 虽然本身只有 512 字节，但还要为其 所用的栈分配点空间，所以其实际所用的内存空间要大于 512 字节，估计 1KB 内存够用了。 结合以上三点，选择32KB中的最后1KB最为合适，那此地址是多少呢？32KB换算为十六进制为0x8000， 减去 1KB(0x400)的话，等于 0x7c00。这就是倍受质疑的 0x7c00 的由来，这下清楚了

------


## 第三章：完善MBR

### 计算机启动过程

![alt text](image-2.png)

### CPU的实模式

实模式是指8086CPU的寻址方式、寄存器大小、指令用法等，可以反应CPU在该环境下如何工作。

**“实” 体现在程序中的地址都是真实的物理地址。**

#### CPU工作原理
CPU划为控制单元、运算单元、存储单元。
控制单元去下一条待运行的指令并存入指令译码器。指令译码器将相应的操作数从内存中取回放入自己的存储单元。运算单元开工

#### CPU的寄存器

寄存器是一种物理存储元件，比一般的存储介质要快。

一般分为两类：**对程序员可见的和对程序员不可见的（内部使用的）**，主要说下对程序员可见的寄存器。

**段寄存器**：指定一片内存的起始地址，也叫段基址，在实模式下乘以16,在保护模式下是一个选择子。

![alt text](image-3.png)

**通用寄存器（每个寄存器功能不单一）：** AX、BX、CX、DX、SI、DI、BP、SP

1. ​	**AX寄存器：累加器**，由AH寄存器（AX高8位）和AL寄存器（AX低8位）组成
2. ​	**CX寄存器：计数器**，用作循环次数的控制
3. ​	**BX寄存器：基址寄存器**，用于存储起始地址
4. ​	**DX寄存器：数据寄存器**，通常只用于保存外设控制器的端口号地址
5. ​	**SI寄存器：源変址寄存器**，用于字符串操作中的数据源地址，即被传送的数据在哪里
6. ​	**DI寄存器：目的変址寄存器**，和SI一样，但是是数据的目的地址，即被传送的数据目的地址在哪里
7. ​	**SP寄存器：栈指针寄存器**，段基址为SS,用来指向栈顶
8. ​	**BP寄存器：基址指针**，BP的方式把栈当成普通的数据段来访问

#### 实模式下CPU内存寻址方式

寻址方式，从大方向来看可以分为三大类：

+ 寄存器寻址
+ 立即数寻址
+ 内存寻址
  + 直接寻址
  + 基址寻址
  + 变址寻址
  + 基址变址寻址

#### 寄存器寻址

最直接的寻址方式就是寄存器寻址,它是指“数”在寄存器中,直接从寄存器中拿数据就行了。例如下面用 `mul` 指令实现 `0x10*0x9。`

```assembly
mov ax,0x10
mov dx,0x9
mul dx
```

同时这也是立即数寻址

#### 立即数寻址

```assembly
mov ax,0x18
mov ds,ax
```

第一条指令中的源操作数 `0x18` 是立即数,目的操作数 `ax` 是寄存器,所以它既是立即数寻址,也是寄存器寻址。第二条指令中,源操作数和目的操作数都是寄存器,所以纯粹是寄存器寻址。

下面也是立即数寻址

```assembly
mov ax,macro_selector
mov ax,label_start
```

第一条指令的源操作数 `macro_selector` 是个宏,第二条指令的源操作数 `label_start`是个标号,这两个在编译阶段会转换为数字,最终可执行文件中的依然是立即数。

#### 内存寻址

##### 直接寻址

直接寻址,就是将直接在操作数中给出的数字作为内存地址,通过中括号的形式告诉 `CPU`,取此地址中的值作为操作数。

```assembly
mov ax,[0x1234]
mov ax,[fs:0x5678]
```

注意，这里`0x1234`是段偏移地址，默认的段地址是`DS`，这条指令是将内存地址 `DS:0x1234` 处的值写入 `ax` 寄存器。段基址*16 变成 20 位地址后,再加上段内偏移地址 `0x1234`。

##### 基址寻址

基址寻址,就是在操作数中用 bx 寄存器或寄存器作为地址的起始,地址的变化以它为基础。**这里说的是只能用`bx`或`bp`作为基址寄存器**

`bx` 寄存器的默认段寄存器是 `DS`,而 `bp` 寄存器的默认段寄存器是 `SS`

> `bp`是用来访问栈的，另外一个用来访问栈的寄存器是`sp`。`sp`寄存器用`push`和`pop`指令来操作栈，但这样只能访问到栈顶。寄存器`bp`可以给出栈中偏移量，所以`bp`默认的段寄存器`SS`,这样就可以通过`SS：bp`的方式把栈当成普通的数据段来访问

```ass
section .data
    ; 数据段，定义一些数据
    base_array db 10, 20, 30, 40, 50

section .text
    global _start

_start:
    ; 设置基址寄存器
    mov esi, base_array

    ; 设置偏移量
    mov ecx, 2  ; 假设要访问数组的第三个元素，偏移量为 2

    ; 计算内存地址，基址 + 偏移量
    add esi, ecx

    ; 在这个例子中，esi 中存储了要访问的内存地址

    ; 可以进行其他操作，比如将该地址的值加载到寄存器中
    mov al, [esi]  ; 将基址 + 偏移量处的值加载到 al 寄存器

    ; 现在，al 中存储了数组第三个元素的值，即 30

    ; 退出程序
    mov eax, 1     ; syscall number for exit
    xor ebx, ebx   ; status: 0
    int 0x80       ; call kernel

```

##### 変址寻址

変址寻址和基址寻址类似，只是寄存器有`bx`、`bp`换成了`si`和`di`。`si`是源索引寄存器，`di`是目的索引寄存器。两个寄存器默认的段寄存器都是`ds`。

```assembly
mov [di],ax  ;将寄存器ax的值存入ds：di指向的内存
mov [si+0x1234],ax    ;変址中也可以加偏移量
```

##### 変址基址寻址

```assembly
mov [bx+di],ax
add [bx+si],ax
```

第一条指令是将 `ax` 中的值送入以 `ds` 为段基址,`bx`+`di` 为偏移地址的内存。第二条指令是将 `ax` 与`[ds:bx+si]`处的值相加后存入内存`[ds:bx+si]`。

### 实模式下的ret

+ `call` 指令调用一个函数时,压入返回地址,为将来能够回来埋下伏笔。`call` 指令不负责“回来”,它只负责如何“去”,回来的工作要交给 `ret`。

+ 对于 `CPU` 来说,它是靠程序计数器 `PC` 来指路的,所以路就在 `PC` 中。在 `x86` 中的程序计数器是 `CS`:`IP`
  + ret（return）指令的功能是在栈顶（寄存器 ss：sp 所指向的地址）弹出 2 字节的内容来替换 IP 寄存器
  + retf（return far）是从栈顶取得 4 字节，栈顶处的 2 字节用来替换 IP 寄存器，另外的 2 字节用来替换 CS 寄存器。

### 实模式下的call

`call`的调用有四种方式

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16 位实模式直接绝对远调用
- 16 位实模式间接绝对远调用

先解释一下近这个概念。

> 近说明`call`指令所调用的目标函数和当前代码段是同一个段，不用切换段，不用换段基址，只需给出段偏移地址

#### 16位实模式相对近调用

名字上和“近”有关的调用就可以用关键字 `near` 来修饰,`near` 表示在内存或寄存器中取 2 字节,这是一种数据类型转换,和数据类型伪指令 `word` 作用相同。`near` 可以省略,`nasm` 编译器默认在地址处取 2 字节。

> 指令格式是 call near 立即数地址

假如 `proc_name` 被编译器分配的地址是 `0x1234`,**`call` 指令最终的操作数并不是 `0x1234`,而是目标地址减去当前 `call` 指令的地址,所得的差再减去此指令的长度 3,最终的结果才是 `call` 相对近调用指令的操作数**

#### 16位实模式间接绝对近调用

**“间接”：目标函数地址没有直接给出，要么在寄存器中，要么在内存中。**

**“绝对”：目标函数地址是绝对地址。**

依然是近调用，只给出段内偏移就好，不用段基址。

#### 16位实模式直接绝对远调用

**“直接”：操作数在指令中直接给出，是立即数，不经过寄存器或内存。**

指令形式如下：

```assembly
call far 段基址（立即数）:段内偏移地址（立即数）
```

```assembly
section call_test vstart=0x900
call 0:far_proc
jmp $
far_proc:
	mov ax,0x1234
	retf
```

#### 16位实模式间接绝对远调用

不支持寄存器寻址，只支持内存寻址。

指令格式：

```assembly
call far 内存寻址
/*call far [bx]
call far [0x1234]
*/
```

```assembly
section call_test vstart=0x900
call far [addr]
jmp $
addr dw far_proc,0
far_proc:
	mov ax,0x1234
	retf
```

### 实模式下的jmp

无条件跳转，改变CPU航线，将程序流转移到新的位置，只要CS:IP寄存器值，不需要保存他们的值。

一共有5类转移方式 ：

- 16位实模式相对短转移：操作数范围为-128～127

  ​	格式：

  ​	

  ```assembly
  jmp short 立即数
  ```

  ​	jmp的操作数CPU不能直接用，是个地址差（目标地址减去jmp所在地址，再减去jmp指令机器码大小2字节）

- 16位实模式相对近转移

指令格式是 jmp near 立即数地址，其操作码是 0xe9。指令中的立即数地址也要经过编译器转换为地址偏移量，再变成机器指令中的操作数。

- 16位实模式间接绝对近转移

指令格式是 jmp near 寄存器寻址，或者 jmp near 内存寻址。

- 16位实模式直接绝对远转移

指令的一般形式是： jmp far 段基址（立即数）：段内偏移地址（立即数）


- 16位实模式间接绝对远转移

指令格式是：jmp far 内存寻址。

> 以上均属于无条件转移


### 让我们直接对显示器说点什么吧

#### CPU如何与外设通信—IO接口

IO接口是连接CPU与外部设备的逻辑控制器件，分为硬件和软件两部分。

**硬件部分**：协调CPU和外设之间的不匹配，如速度不匹配

**软件部分**：用来控制接口电路工作的驱动程序以及完成内部数据传输所需要的数据
  
+ IO 接口的功能：

- 设置数据缓冲，解决与外设速度不匹配问题
- 设置信号电平转换电路
- 设置数据格式转换
- 设置时序电路同步CPU与外设
- 提供地址译码

同一时刻，CPU只能和一个IO接口通信，其中输入输出控制中心（南桥芯片）解决竞争问题，以及连接内部总线。（北桥一般连接告诉设备，内存等）

------

+ 端口是IO接口开放给CPU的接口（不同于网络应用程序中所开的端口）

in 指令用于从端口中读取数据，其一般形式是： 

+ in al, dx
+ in ax, dx

 其中 al 和 ax 用来存储从端口获取的数据，dx 是指端口号。 这是固定用法，只要用 in 指令，源操作数（端口号）必须是 dx，而目的操作数是用 al，还是 ax，取 决于 dx 端口指代的寄存器是 8 位宽度，还是 16 位宽度。

out 指令用于往端口中写数据，其一般形式是： 

+ out dx, al
+ out dx,ax
+ out 立即数, al
+ out 立即数, ax

注意啦，这和 in 指令相反，in 指令的源操作数是端口号，而 out 指令中的目的操作数是端口号。

#### 显卡概述 

显卡也称为显示适配器，不过归 根结底它就是 IO 接口，专门用来连接 CPU 和显示器。我们想操作显示器，没有直接的办法，只能通过它 的 IO 接口—显卡。显卡的工作就是不断地读取显存，随后将其内容发送到显示器。

#### 显存、显卡、显示器 


### 硬盘介绍



#### 硬盘控制器端口

端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作状态。



device 寄存器是个杂项，很多设置都需集中在此寄存器中了，其中的第 4 位，便是指定通道上的主或从硬 盘，0 为主盘，1 为从盘。在此寄存器的低 4 位用来存储 LBA 地址 的第 24～27 位。结合上面的三个 LBA 寄存器。第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代 表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。另外的两位： 第 5 位和第 7 位是固定为 1 的，称为 MBS 位，

data 寄存器作用是读取或写入数据，在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，我们要把数据源源不断地输送到此端口， 数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。

在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的 状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错了，具体原因可见 error 寄存器。第 3 位是 data request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来。第 6 位是 DRDY， 表示硬盘就绪，此位是在对硬盘诊断时用的，表示硬盘检测正常，可以继续执行一些命令。第 7 位是 BSY 位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙着，此寄存器中的其他位都无效。另外的 4 位暂不关注。

在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况 一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬 盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。在咱们的系统中，主要使用了三个命令：

1. identify：0xEC，即硬盘识别。
2. read sector：0x20，即读扇区。
3. write sector：0x30，即写扇区。


#### 常用的硬盘操作方法 

1. 先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
2. 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
3. 往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
4. 往该通道上的 command 寄存器写入操作命令。
5. 读取该通道上的 status 寄存器，判断硬盘工作是否完成。
6. 如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
7. 将硬盘数据读出。

一般常用的数据传送方式如下：

1. 无条件传送方式。
2. 查询传送方式。
3. 中断传送方式。
4. 直接存储器存取方式（DMA）。
5. I/O 处理机传送方式。

> loader 为什么在0x900

可用区域”的地方都可以用。 0x500～0x7BFF 和 0x7E00～9FBFF 这两段内存区域都可以。

首先，loader 中要定义一些数据结构（如 GDT 全局描述符表，不懂没关系，以后会说），这些数据结 构将来的内核还是要用的，所以 loader 加载到内存后不能被覆盖。 其次，随着咱们不断添加功能，内核必然越来越大，其所在的内存地址也会向越来越高的地方发展， 难免会超过可用区域的上限，咱们尽量把 loader 放在低处，多留出一些空间给内核。 所以，我将 loader 的加载地址选为 0x900。为什么不是 0x500，这个多省空间？还是预留出一定空间 吧，彼此隔开远一点心里才踏实，不差这点空间了，

